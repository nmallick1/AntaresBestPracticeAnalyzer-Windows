param([string]$resourceToProcess, [string]$currDetectorName) #Must be the first statement in the script

<#
1. Make sure there are no spaces in the Detector script name. Place your Detector script within a folder with the same name as your detector script. You can then put this folder inside the \Detectors\Sites or Detectors\ASPs directory
For e.g.. The sample SlotsDetector.ps1 is a Sites Detector and its script is placed inside \Detectors\Sites\SlotsDetector\SlotsDetector.ps1

2. No individual Detector should take more than a few minutes to complete. It runs a risk of being terminated if it runs for a long time
Timeout for a Site detector is 6 minutes and for an ASP detector is 10 minutes

3. As a rule of thumb, if you are downloading any file that you need for your detector to function, download it in the Sites directory respresnted by $resourceToProcess instead of the directory in which your Detectory resides.
You may choose to clean up / leave the downloaded data as is. Just in case any other detectory needs it, it will already have it there.
Simillarly, if you need a file downloaded / some data, check for its presence. Chances are, some other detector might have already done the work for you


4. $resourceToProcess will have input in the following format
    C:\Projects\AntaresBestPracticeAnalyzer-Windows\Output\da511dea-6e00-4728-93ff-6302ad7fe284\Sites\da511dea-6e00-4728-93ff-6302ad7fe284_nmallickWebAppRG_nmallick1

5. Once done with the detector logic, create a file with the following naming convention and place it in the same folder as $resourceToProcess
    DetectorName.out.

    For e.g. If the detector's name is SlotsDetector, the output file generated by this detector should be SlotsDetector.out and should be placed at $resourceToProcess +"\SlotsDetector.out".
    $detectorOutputFile valiable already creates the complete file path for you.

    The output file should contain and output in the following JSON format

    {
    "SubscriptionId": "This should be the Subscription ID under which the current site resides",
    "ResourceGroupName": "This should be the resource grop name under which the current site resides",
    "ResourceName": "This should be either the name of the webapp or ASP that the detector is currently processing",
    "Kind": "Make sure value is one out of SiteDector | ASPDetector",
    "DetectorName": "SlotsDetector",
    "Author": "Feel free to addd your name and/or email address or simply state Anonymous"
    "Description": "In short, state which best practice does your detector checks against",
    "Result":{
        "Value": "Make sure value is one out of Pass | Fail | Warning",
        "Details": "Any string decribing what is the conclusion of your detector",
        "Recommendation": "What is your recommendation for this site and why",
        "AdditionalInfo":"Anything else that you want to point out goes here"
        }
    }

6. Add a small description of what your detector checks for / which best practice is it trying to look for in the corresponding ReadMe.txt. It will help people understand the intent of this detector.

7. There is a return statement in PlaceHolderDetector.ps1. Remove / Comment it before working on your detector. It is placed to ensure that the PlaceHolderDetecor does not run any logic if trigerred

8. The order in which Detectors will be invoked is not guaranteed, however they are certain to be invoked ONLY once per Site / ASP.
#>




#region Do not change anything in this section
    $detectorOutputFile = $resourceToProcess + "\" + $currDetectorName  + ".out"

    if(Test-Path -Path $detectorOutputFile){
        #Output for this detector already exists. Must have been trigerred due to some bug / error. Do not run the detector logic again
        return
    }

    $temp = $resourceToProcess.Split('\')[$resourceToProcess.Split('\').Length-1]

    $subscriptionId = $temp.Split('_')[0]
    $resourceGroup = $temp.Split('_')[1]
    $resourceName = $temp.Split('_')[2]

    #The complete path of the JSON file that contains settings for this resource is $resourceToProcess + "\" + $settingsFileName
    $settingsFileName = $resourceName + ".json"

    #Initialize
    $adheringToBestPractice = $true
#endregion Do not change anything in this section

#region Code for your detector goes here
    $siteProperties = Get-Content -Path ($resourceToProcess + "\" + $settingsFileName) |ConvertFrom-Json

    #This check is to make sure site is not in free or shared as we cant enable alwayson option
    If($siteProperties.sku -eq "Basic" -or $siteProperties.sku -eq "Standard" -or $siteProperties.sku -eq "Premium" -or $siteProperties.sku -eq "Isolated")
    {
       
        $siteConfigURL = "/subscriptions/" + $subscriptionId + "/resourceGroups/" + $resourceGroup + "/providers/Microsoft.Web/sites/" + $resourceName + "/config?api-version=2016-08-01"
        $siteConfigForThisSite = ARMClient.exe Get $siteConfigURL | ConvertFrom-Json
        if($siteConfigForThisSite.value.properties.alwaysOn)
        {
            $adheringToBestPractice = $true            
        }
        else
        {
            #The alwayson option is off
            $adheringToBestPractice = $false 
            $failureDetails = "you should enable alwayson setting to avoid application getting stopped when the idletimeout (20 minutes) is hit and this ensures better application performance."
        }
    }
    else
    {
        #alwayson option cannot be enabled as the site is either in free or shared plan.
        $adheringToBestPractice = $false
        $failureDetails =  "you should enable alwayson setting to avoid application getting stopped when the idletimeout (20 minutes) is hit. You cannot enable this feature on Free or Shared Hosting plan so migrate to Standard or above to get this feature enabled."
    }

#endregion  Code for your detector goes here

#region Generate output for the detector
    #region Modify the text in variables as appropriate
        If($adheringToBestPractice){
            #Enter this block if you logic found that the best practice you are checking for is already implemented for this site
            $detectorResult = @{
                'Value'='Pass';
                'Details'='AlwaysOn Feature is enabled. This ensures better app performance as the idletimeout will not affect the application';
                'Recommendation'='';
                'AdditionalInfo'=''
                }
        }
        else
        {
            #Enter this block if you logic found that the best practice you are checking for is already implemented for this site
            $detectorResult = @{
                'Value'='Fail';
                'Details'= $failureDetails;
                'Recommendation'='';
                'AdditionalInfo'="For more information on understanding how to enable this feature please read https://docs.microsoft.com/en-us/azure/app-service/web-sites-configure"
                }
        }




        #region Generating output for the detector
        $outputObj = New-Object System.Object
        $outputObj  | Add-Member -MemberType NoteProperty -Name SubscriptionId -Value $subscriptionId
        $outputObj  | Add-Member -MemberType NoteProperty -Name ResourceGroupName -Value $resourceGroup
        $outputObj  | Add-Member -MemberType NoteProperty -Name ResourceName -Value $resourceName
        $outputObj  | Add-Member -MemberType NoteProperty -Name Kind -Value "SiteDetector"
        $outputObj  | Add-Member -MemberType NoteProperty -Name DetectorName -Value $currDetectorName
        $outputObj  | Add-Member -MemberType NoteProperty -Name Author -Value "Mohammed Fasiulla (mofasiul@microsoft.com)"
        $outputObj  | Add-Member -MemberType NoteProperty -Name Description -Value "Ensure AlwaysOn option is Enabled."
        $outputObj  | Add-Member -MemberType NoteProperty -Name Result -Value $detectorResult



    #endregion  Modify the text in variables as appropriate

    #region Write output to .out file
        #Create a placeholder file
        New-Item -ItemType File -Path $detectorOutputFile -Force >$null

        #Write the properties of this website into its corresponding file
        $outputObj | ConvertTo-Json | Out-File -FilePath $detectorOutputFile -Append  -Force
    #endregion Write output to .out file
#endregion  Generate output for the detector